// File: appraisals-backend/src/services/utils/githubService.js\n\n// Ensure \'axios\' and \'@google-cloud/secret-manager\' are installed\n// npm install axios @google-cloud/secret-manager \nconst axios = require(\'axios\');\nconst { SecretManagerServiceClient } = require(\'@google-cloud/secret-manager\');\n\n// --- Configuration Store ---\n// Caches secrets after first fetch\nconst fetchedConfig = {\n  githubToken: null,\n  githubRepoOwner: null,\n};\nlet secretsFetched = false;\n\n// --- Environment-based Configuration ---\nconst envConfig = {\n  githubRepoName: process.env.GITHUB_REPO_NAME, // From environment\n  projectId: process.env.GOOGLE_CLOUD_PROJECT_ID, // Use specific env var name\n  serviceName: process.env.K_SERVICE || \'appraisals-backend\',\n  githubTokenSecretName: \'GITHUB_TOKEN\', // Name of the token secret\n  githubRepoOwnerSecretName: \'GITHUB_REPO_OWNER\', // Name of the owner secret\n  githubApiUrl: \'https://api.github.com\'\n};\n\nconst secretManagerClient = new SecretManagerServiceClient();\n\n// --- Helper Functions ---\n\n/**\n * Fetches a single secret from Google Secret Manager.\n * @param {string} secretName The name of the secret.\n * @returns {Promise<string>} The secret value.\n * @throws {Error} If configuration is missing or fetch fails.\n */\nasync function fetchSecret(secretName) {\n  if (!envConfig.projectId) {\n    throw new Error(`Missing ${process.env.GOOGLE_CLOUD_PROJECT_ID ? 'GOOGLE_CLOUD_PROJECT_ID' : 'GOOGLE_CLOUD_PROJECT'} environment variable for Secret Manager.`);\n  }\n  const secretPath = `projects/${envConfig.projectId}/secrets/${secretName}/versions/latest`;\n  console.log(`[GithubService] Fetching secret: ${secretPath}`);\n  try {\n    const [version] = await secretManagerClient.accessSecretVersion({ name: secretPath });\n    const payload = version.payload?.data?.toString('utf8');\n    if (!payload) {\n      throw new Error(`Fetched secret payload is empty for ${secretName}.`);\n    }\n    console.log(`[GithubService] Successfully fetched secret: ${secretName}`);\n    return payload;\n  } catch (error) {\n    console.error(`[GithubService] Failed to fetch secret ${secretName}:`, error);\n    throw new Error(`Could not retrieve secret ${secretName} from Secret Manager.`);\n  }\n}\n\n/**\n * Fetches and caches required secrets (token, owner) from Secret Manager.\n * Runs only once.\n * @returns {Promise<void>}\n * @throws {Error} If any secret fetch fails.\n */\nasync function ensureSecretsFetched() {\n  if (secretsFetched) {\n    return;\n  }\n  console.log('[GithubService] Ensuring secrets are fetched...');\n  try {\n    // Fetch secrets in parallel\n    const [token, owner] = await Promise.all([\n      fetchSecret(envConfig.githubTokenSecretName),\n      fetchSecret(envConfig.githubRepoOwnerSecretName)\n    ]);\n    fetchedConfig.githubToken = token;\n    fetchedConfig.githubRepoOwner = owner;\n    secretsFetched = true;\n    console.log('[GithubService] All required secrets fetched and cached.');\n  } catch (error) {\n    console.error('[GithubService] Fatal: Failed to fetch required secrets on startup.', error);\n    secretsFetched = false; // Allow retry on next call maybe? Or handle fatal error.\n    throw error; // Re-throw so the application knows secrets are missing\n  }\n}\n\n/**\n * Extracts Trace ID from the X-Cloud-Trace-Context header.\n * @param {string | undefined} traceHeader - The value of the header.\n * @returns {string | null} The extracted Trace ID or null if not found/invalid.\n */\nfunction extractTraceId(traceHeader) {\n    if (!traceHeader) return null;\n    // Format: TRACE_ID/SPAN_ID;o=TRACE_TRUE\n    const parts = traceHeader.split(\'/\');\n    return parts[0] || null;\n}\n\n/**\n * Constructs a URL to the Google Cloud Logs Explorer for a specific trace.\n * @param {string | null} traceId - The Trace ID.\n * @returns {string | null} The Logs Explorer URL or null if essential info is missing.\n */\nfunction generateLogExplorerLink(traceId) {\n    if (!traceId || !envConfig.projectId || !envConfig.serviceName) {\n        return null;\n    }\n    const query = `resource.type="cloud_run_revision" resource.labels.service_name="${envConfig.serviceName}" trace="projects/${envConfig.projectId}/traces/${traceId}"`;\n    const encodedQuery = encodeURIComponent(query).replace(\'%20\',\'+\').replace(\'%2F\',\'/\'); // Basic encoding\n    return `https://console.cloud.google.com/logs/query;query=${encodedQuery};?project=${envConfig.projectId}`;\n}\n\n// --- Core Function ---\n\n/**\n * Creates a GitHub issue for a given error.\n * Includes a link to Cloud Run logs if possible. Does NOT include duplicate detection yet.\n *\n * @param {Error} error The error object caught by the handler.\n * @param {import(\'express\').Request} [req] Optional Express request object to extract context.\n * @param {string} [serviceNameOverride] Optional override for service name.\n */\nasync function createGithubIssue(error, req, serviceNameOverride) {\n  const serviceName = serviceNameOverride || envConfig.serviceName;\n\n  // Ensure secrets are loaded (will fetch on first call)\n  try {\n    await ensureSecretsFetched();\n  } catch (configError) {\n    console.error('[GithubService] Required configuration unavailable, cannot create issue:', configError);\n    return; // Fail silently if secrets couldn't be loaded\n  }\n\n  // Validate essential runtime config\n  if (!envConfig.githubRepoName) {\n    console.error('[GithubService] Missing GITHUB_REPO_NAME environment variable. Cannot create issue.');\n    return;\n  }\n   // Secrets should be validated within ensureSecretsFetched, but double-check cache\n  if (!fetchedConfig.githubRepoOwner || !fetchedConfig.githubToken) {\n     console.error('[GithubService] Cached secrets (Owner or Token) are missing. Cannot create issue.');\n     return;\n  }\n\n  // Extract context\n  const requestMethod = req?.method || \'N/A\';\n  const requestUrl = req?.originalUrl || \'N/A\';\n  const traceHeader = req?.headers?.[\'x-cloud-trace-context\'];\n  const traceId = extractTraceId(traceHeader);\n  const logLink = generateLogExplorerLink(traceId);\n\n  // Format Issue\n  const title = `[Backend Error - ${serviceName}] ${error.message.substring(0, 100)}${error.message.length > 100 ? \'...\' : \'\'}`; // Truncate long messages\n  let body = `**Error:** ${error.message}\\n\\n`;\n  body += `**Service:** ${serviceName}\\n`;\n  body += `**Request:** ${requestMethod} ${requestUrl}\\n`;\n  body += `**Timestamp:** ${new Date().toISOString()}\\n`;\n  if (traceId) {\n    body += `**Cloud Trace ID:** \`${traceId}\`\\n`;\n  }\n  if (logLink) {\n    body += `**Logs Explorer Link:** [View Logs](${logLink})\\n\\n`;\n  }\n  body += \'**Stack Trace:**\\n```\\n\';\n  body += error.stack || \'No stack trace available.\';\n  body += \'\\n```\';\n\n  // Use fetched/cached config values\n  const issueUrl = `${envConfig.githubApiUrl}/repos/${fetchedConfig.githubRepoOwner}/${envConfig.githubRepoName}/issues`;\n\n  // TODO: Implement duplicate check here before creating\n\n  try {\n    console.log(`[GithubService] Attempting to create GitHub issue: ${title}`);\n    const response = await axios.post(\n      issueUrl,\n      { title, body },\n      {\n        headers: {\n          \'Authorization\': `Bearer ${fetchedConfig.githubToken}`,\n          \'Accept\': \'application/vnd.github.v3+json\',\n          \'Content-Type\': \'application/json\',\n        },\n        timeout: 10000 // Add a timeout for the GitHub API call\n      }\n    );\n    console.log(`[GithubService] Successfully created GitHub issue: ${response.data?.html_url}`);\n  } catch (githubError) {\n    // Log error details if possible\n    const errorMessage = githubError.response?.data?.message || githubError.message;\n    console.error(`[GithubService] Failed to create GitHub issue (${githubError.response?.status}):`, errorMessage);\n    // Optionally log githubError.response?.data?.errors for more details\n  }\n}\n\n// Optional: Call ensureSecretsFetched once during application startup\n// This pre-fetches secrets so the first error doesn't have fetch latency.\n// You would call this in your main index.js/app.js before starting the server.\n// ensureSecretsFetched().catch(err => {\n//   console.error(\"Failed to pre-fetch secrets on startup:\", err);\n//   // Decide if this is a fatal error preventing startup\n// });\n\nmodule.exports = {\n  createGithubIssue,\n  // Optional: export ensureSecretsFetched if you want to call it at startup\n  // ensureSecretsFetched\n}; 